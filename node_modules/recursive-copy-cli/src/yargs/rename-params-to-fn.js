"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.renameParamsToFunction = void 0;
var flow_1 = __importDefault(require("lodash/fp/flow"));
var requireTryAll_1 = require("./requireTryAll");
// eslint-disable-next-line complexity, @typescript-eslint/prefer-readonly-parameter-types
function renameParamsToFunction(argv) {
    var rename = undefined;
    if (argv.renameModule) {
        var renameFnList_1 = argv.renameModule.map(function (module) { return requireTryAll_1.requireTryAll(module); });
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        rename = function (src) { return flow_1["default"](renameFnList_1)(src); };
    }
    else if (argv.renamePattern) {
        var _a = argv.renamePattern, regexpStr = _a[0], substitute_1 = _a[1];
        var regParts = /^\/(.*?)\/([gim]*)$/.exec(regexpStr);
        // eslint-disable-next-line @typescript-eslint/init-declarations
        var regexp_1;
        if (regParts) {
            // the parsed pattern had delimiters and modifiers. handle them.
            // if flags is "", use undefined as you cant pass "" to new RegExp
            var flags = regParts[2] || undefined;
            regexp_1 = new RegExp(regParts[1], flags);
        }
        else {
            // we got pattern string without delimiters
            regexp_1 = new RegExp(regexpStr);
        }
        rename = function (src) { return src.replace(regexp_1, substitute_1); };
    }
    if (rename) {
        argv.rename = rename;
    }
}
exports.renameParamsToFunction = renameParamsToFunction;
